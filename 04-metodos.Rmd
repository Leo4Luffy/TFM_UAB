```{r, echo = FALSE}

pacman::p_load(cowplot, magick, tibble, gt, dplyr, ggplot2, showtext, here, readr, scales, pedigreemm, patchwork, latex2exp)
font_add_google('Gochi Hand', 'gochi')
showtext_auto()
```

<!-- Para renderizar: bookdown::render_book("index.Rmd", "bookdown::pdf_book") -->

<!--
## Introducción {#intro2}

La teoría de la genética en el estudio de caracteres cuantitativos se estableció hace más de un siglo cuando Ronald Fisher presentó un documento [@cite:1] donde dio a conocer el desarrollo de la teoría del modelo infinitesimal, permitiendo con ello unificar dos de las escuelas de pensamiento que para ese entonces estaban en constante debate: la escuela de pensamiento Mendeliano, cuyo objetivo consistía en localizar y caracterizar factores de herencia, y la escuela de pensamiento biométrico, cuyo origen se remonta a Galton quien buscaba aplicar modelos biométricos con el fin de estudiar las relaciones entre parientes [@cite:2; @cite:3].

La teoría del modelo infinitesimal desarrollado por Fisher establece que la varianza genética de un carácter esta determinado por un gran número de factores Mendelianos, cada uno de los cuales tiene una pequeña contribución aditiva al fenotipo de dicho carácter [@cite:2; @cite:9]. Naturalmente, los modelos usados en estudios de mejoramiento genético han sido concebidos en base a esta teoría [@cite:4; @cite:5], siendo ejemplo de ello el mejor predictor lineal insesgado (BLUP) y el mejor predictor lineal insesgado genómico (GBLUP).

En las ciencias animales, el valor de cría estimado (EBV) se suele predecir en función de un conjunto de modelos que relacionan el fenotipo de una población con la información del pedigrí, mediante el uso del BLUP. No obstante, este método no es factible para poblaciones sin información de pedigrí o con una estructura poblacional compleja, como suele ser el caso de las plantas [@cite:6; @cite:7]. Para el año 2001, Meuwissen, Hayes y Goddard propusieron un método innovador para predecir los valores de cría basado en marcadores de ADN (GEBV), denominándose tiempo después como selección genómica [@cite:6; @cite:3], el cual permitió también superar las limitaciones que suponía el uso del BLUP para predecir los valores de cría en plantas.

Hoy en día, la selección genómica se considera como un método potencial para el mejoramiento genético en plantas [@cite:6], ya que sus ciclos reproductivos suelen ser prolongados, por lo cual con el uso de la selección genómica es posible acelerar dichos ciclos reproductivos con el beneficio adicional de mejorar la tasa de ganancia genética anual por unidad de tiempo y costo [@cite:10; @cite:11]. Además, los datos sobre marcadores de ADN en todo el genoma están cada vez más disponibles para cultivos de relevancia agronómica [@cite:7].

El GBLUP es uno de los métodos más comunes de selección genómica [@cite:11]. De hecho, es el método más popular debido a su simplicidad al sustituir la matriz de relación de parentesco basado en pedigríes [@cite:12] por una matriz de relación basada en marcadores de ADN [@cite:13]. Así mismo, el GBLUP predice con mayor precisión los GEBV en comparación a los EBV del BLUP, debido a que con el primero se estima mejor las relaciones entre individuos [@cite:14], por lo cual la matriz de las relaciones genómicas suele verse como un estimador mejorado de las relaciones basadas en marcadores en lugar de pedigríes [@cite:15].

En términos generales, la selección genómica es un proceso de tres pasos en el que los individuos, sobre la base de su información fenotípica y de pedigrí, son evaluados inicialmente mediante una evaluación genética tradicional por medio del BLUP, y posteriormente a partir de los fenotipos corregidos o pseudo-fenotipos resultantes de esta evaluación genética inicial, es llevado a cabo un análisis genómico de los individuos genotipados mediante el GBLUP. Por último y en base a la información generada, se calculan los GEBV por medio de un índice de selección [@cite:17; @cite:16; @cite:14; @cite:15; @cite:18].

Como no todos los individuos pueden genotiparse, la selección genómica se lleva a cabo a partir del proceso anterior de tres pasos [@cite:17]. Sin embargo, este proceso es tendente a cometer errores [@cite:14], además de presentar inconvenientes como son la perdida de información y la difícultad de generalizarse a caracteres múltiples y maternos [@cite:17; @cite:15]. Conscientes de esto, @cite:17 simplificaron el proceso de varios pasos al desarrollar un método de selección genómica, en el que los fenotipos de los individuos genotipados y no genotipados se analizan conjuntamente para predecir sus valores de cría [@cite:20; @cite:11], método el cual se denomino como mejor predictor lineal insesgado genómico de un solo paso (ssGBLUP).

En el ssGBLUP se dispone de una matriz de parentesco genómica global de individuos genotipados y no genotipados, denominada como matriz de relación combinada o matriz H. Esta matriz se obtiene combinando información de la relación genómica entre individuos genotipados, e información de pedigrí entre individuos genotipados y no genotipados [@cite:20]. Con ello, el proceso anterior de tres pasos tiende a simplificarse al incorporar la información genómica desde el primer paso [@cite:15; @cite:16], sin la necesidad del calculo posterior de fenotipos corregidos y la construcción del índice de selección mencionado previamente [@cite:18].

Al ser una forma de BLUP en el que la matriz de relación de parentesco es sustituida por la matriz de relación combinada [@cite:17; @cite:15; @cite:21], el ssGBLUP se puede adecuar con facilidad a caracteres múltiples y maternos [@cite:21], además se adapta también a las herramientas informaticas ya desarrolladas en base al BLUP [@cite:22]. Este hecho hace del ssGBLUP un método de uso rutinario para la evaluación genómica en animales, donde ha demostrado que produce una predicción más precisa de los valores de cría en comparación a los métodos BLUP y GBLUP antes mencionados [@cite:14; @cite:19; @cite:18]. No obstante, el uso del ssGBLUP para la selección genómica en plantas es más reciente y escaso [@cite:19; @cite:11]. En consecuencia, el __objetivo__
-->

# Materiales y métodos
  
## Recurso vegetal y datos fenotípicos

Los conjuntos de datos se obtuvieron del Rice SNP-Seek Database (disponible en la dirección web o URL http://iric.irri.org/), que contiene información sobre datos de genotipado de SNP y de fenotipos de distintas variedades de arroz (*Oryza sativa L.*). En un estudio previo a este [@cite:26], los genotipados de SNP fueron sometidos a procedimientos de control de calidad, eliminando loci con una frecuencia del alelo menor inferior a 0.01 y con una tasa de ausencia mayor a 0.01. Para este estudio se eliminaron loci con una frecuencia del alelo menor inferior a 0.05 usando Plink [@cite:49].

Luego, el conjunto de datos de genotipado final se transformó de la codificación de genotipo de nucleótidos (esto es, A, C, T y G) a la codificación numérica (0, 1 y 2 para los homocigotos de clase I, heterocigotos y homocigotos de clase II, respectivamente) para facilitar el análisis estadístico posterior.

En la figura a continuación (Figura 4.1) se observa un análisis de componentes principales realizado sobre los datos de genotipado de SNP, donde se observan diferentes grupos varietales de arroz. La variedad indica fue seleccionada para llevar a cabo este estudio ya que es el grupo varietal con mayor número de individuos genotipados (451 individuos de un total de 738).

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', message=FALSE, warning=FALSE}

# 1. Se importan los archivos de datos.

m_dist <- read_table(here('figures', 'PCA_IND.mdist'), col_names = FALSE) %>%
  select(-X739)

ind <- tibble(id = read_table(here('figures', 'PCA_IND.mdist.id'), col_names = FALSE)[, 2]) # Se extrajo el nombre de los individuos.

esp <- read_delim(here('figures', 'all.phenotypes.csv'), delim = ',') %>%
  select(SNPsubsp) # Se extrajo el nombre de las especies (ADM, ARO, AUS, IND y JAP).

# 2. Se calculan los componentes principales en función del escalado multidimensional.

mds_poblacion <- cmdscale(d = m_dist, eig = TRUE, k = 5)

# 3. Se extraen los vectores propios.

vec_propios <- cbind(esp, ind, mds_poblacion$points)

# 4. Se calcula la proporción de la variación explicada por cada valor propio (por los dos primeros componentes principales).

porc_propio <- round(((mds_poblacion$eig) / sum(mds_poblacion$eig)) * 100, digits = 2)

porc_propio_2 <- porc_propio %>%
  as_tibble() %>%
  slice(1:12) %>%
  rowid_to_column(var = 'componente') %>%
  mutate(componente = as.factor(componente))

# 5. Se visualizan los resultados mediante componentes principales.

graf_bar <- ggplot(data = porc_propio_2, aes(x = componente, y = value)) +
  geom_bar(stat = 'identity', color = 'gray34', fill = 'gray34', alpha = 0.4) +
  #theme_transparent() +
  labs(
   x = 'Componente principal',
   y = 'Variación acumulada (%)'
   ) +
  theme(
    axis.text.x = element_text(face = 'bold', size = 7),
    axis.text.y = element_text(face = 'bold', size = 7, angle = 90),
    axis.title = element_text(face = 'bold', size = 8)
    )

Graf_PCA <- ggplot(data = vec_propios, mapping = aes(x = `1`, y = `2`, color = SNPsubsp, fill = SNPsubsp)) +
  geom_point(alpha = 0.2, size = 4.4) +
  stat_ellipse(aes(color = SNPsubsp), type = 't') +
  geom_hline(yintercept = 0, linetype = 'dotted') +
  geom_vline(xintercept = 0, linetype = 'dotted') +
  scale_color_manual(values = c('yellow', 'black', 'red', 'cyan', 'green')) +
  scale_fill_manual(values = c('yellow', 'black', 'red', 'cyan', 'green')) +
  labs(
   x = paste0('Primer componente (',porc_propio[1],' %)'),
   y = paste0('Segundo componente (',porc_propio[2], '%)'),
   col = 'Variedades de arroz', fill = 'Variedades de arroz'
   ) +
  theme_bw() +
  theme(
    legend.background = element_rect(color = 'gray34', fill = 'white', size = 0.4, linetype = 'dashed'),
    legend.position = c(0.18, 0.24),
    legend.text = element_text(size = 11),
    legend.title = element_text(face = 'bold', size = 11),
    axis.text = element_text(face = 'bold', size = 11),
    axis.title = element_text(face = 'bold', size = 12)
    ) #+
  #annotation_custom(
    #ggplotGrob(x = graf_bar), 
    #xmin = -0.10, xmax = -0.02, 
    #ymin = -0.08, ymax = -0.17
    #)

knitr::include_graphics('figures/Graf_PCA.png', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 4.1:__ Análisis de componentes principales en datos de arroz. Los puntos y las circuferencias de color representan los distintos grupos varietales disponibles: tipo intermedio o mezclado (ADM), aromático (ARO), aus (AUS), indica (IND) y japónica (JAP).
:::

De entre los datos de fenotipos disponibles, se eligió el carácter tiempo de floración, ya que en un estudio previo a este [@cite:26] se observo que en este carácter la predicción genómica podría funcionar mejor. Con la figura a continuación  (Figura 4.2) se observa que la distribución empírica general de este carácter fue aproximadamente normal, lo que permitió el uso de modelos de distribución normal. Los datos fenotípicos se centraron (restando la media general) y estandarizaron (dividiendo por la desviación estándar) antes de ajustar los modelos que se describen a continuación.

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', message = FALSE, warning = FALSE}

Fenotipos <- read_delim(here('figures', 'all.phenotypes.csv'), delim = ',')

# Trillabilidad de la panícula (término descriptivo para la facilidad con la que se extrae el grano de la panícula durante la trilla) ----

Rasgo_1 <- Fenotipos %>%
  mutate(panicle.threshability = as.factor(panicle.threshability)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = panicle.threshability)) +
  geom_bar(color = 'yellow', fill = 'yellow', alpha = 0.2) +
  labs(x = 'Trillabilidad de\n la panícula', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Tiempo de floración ----

Rasgo_2 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data = ., aes(x = Time.to.flowering..from.sowing)) +
  geom_density(color = 'yellow', fill = 'yellow', alpha = 0.2) +
  labs(x = 'Tiempo de floración', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10, face = 'bold'),
    axis.text.y = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 10, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

Rasgo_2b <- Fenotipos %>%
  na.omit() %>%
  ggplot(aes(x = ' ', y = Time.to.flowering..from.sowing)) + 
  geom_boxplot(color = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'text', x = 1.4, y = 4.2, label = TeX('$\\bar{x} = 4.57 \\pm 0.23$'), size = 3.2) +
  coord_flip() +
  labs(x = ' ', y = 'Tiempo de floración') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 10, face = 'bold'),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 10, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold'),
    axis.ticks.y = element_blank()
    )

# Daño de la sal ----

Rasgo_3 <- Fenotipos %>%
  mutate(Salt.injury.at.EC12 = as.factor(Salt.injury.at.EC12)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = Salt.injury.at.EC12)) +
  geom_bar(color = 'green', fill = 'green', alpha = 0.2) +
  labs(x = 'Daño de la sal', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Longitud de la hoja ----

Rasgo_4 <- Fenotipos %>%
  mutate(leaf.length = as.factor(leaf.length)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = leaf.length)) +
  geom_bar(color = 'red', fill = 'red', alpha = 0.2) +
  labs(x = 'Longitud de\n la hoja', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Fuerza del culmo ----

Rasgo_5 <- Fenotipos %>%
  mutate(culm.strength = as.factor(culm.strength)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = culm.strength)) +
  geom_bar(color = 'cyan', fill = 'cyan', alpha = 0.2) +
  labs(x = 'Fuerza del culmo', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Senescencia de la hoja ----

Rasgo_6 <- Fenotipos %>%
  mutate(leaf.senescence = as.factor(leaf.senescence)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = leaf.senescence)) +
  geom_bar(color = 'cyan', fill = 'cyan', alpha = 0.2) +
  labs(x = 'Senescencia de\n la hoja', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Ángulo de la hoja bandera ----

Rasgo_7 <- Fenotipos %>%
  mutate(flag.leaf.angle = as.factor(flag.leaf.angle)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = flag.leaf.angle)) +
  geom_bar(color = 'red', fill = 'red', alpha = 0.2) +
  labs(x = 'Ángulo de la\n hoja bandera', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Longitud del grano ----

Rasgo_8 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data =., aes(x = grain.length)) +
  geom_density(color = 'green', fill = 'green', alpha = 0.2) +
  scale_x_continuous(labels = label_number(accuracy = 0.1)) +
  labs(x = 'Longitud del\n grano', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6, face = 'bold'),
    axis.text.y = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Ancho del grano ----

Rasgo_9 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data =., aes(x = grain.width)) +
  geom_density(color = 'black', fill = 'black', alpha = 0.2) +
  labs(x = 'Ancho del\n grano', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6, face = 'bold'),
    axis.text.y = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

# Peso del grano ----

Rasgo_10 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data =., aes(x = Grain.weight)) +
  geom_density(color = 'yellow', fill = 'yellow', alpha = 0.2) +
  scale_x_continuous(labels = label_number(accuracy = 0.1)) +
  labs(x = 'Peso del grano', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6, face = 'bold'),
    axis.text.y = element_text(size = 10, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 10, face = 'bold')
    )

(Rasgo_1 | Rasgo_2 | Rasgo_3 | Rasgo_4 | Rasgo_5) / (Rasgo_6 | Rasgo_7 | Rasgo_8 | Rasgo_9 | Rasgo_10) -> Graf_feno

Rasgo_2 | Rasgo_2b -> Graf_feno_2

knitr::include_graphics('figures/Graf_feno_2.png', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 4.2:__ Distribución y media $\pm$ desviación estándar del carácter tiempo de floración del conjunto de datos fenotípicos de arroz.
:::

## Predicción basada en información de pedigrí e información genómica

Para llevar a cabo la predicción usando el mejor predictor lineal insesgado (BLUP) en individuos no genotipados y el mejor predictor lineal insesgado genómico de un solo paso (ssGBLUP) tanto en individuos genotipados como no genotipados, se aplicó el siguiente modelo:

\begin{equation}
y = 1_{n} \mu + Zg + e,
\end{equation}

donde $y$ representa el valor del fenotipo a predecir (es decir, el tiempo de floración) y $Z$ es la matriz de incidencia que relaciona $g$ con $y$. $1_{n}$ es un vector de unos, $\mu$ es la media de la población, el vector $g$ representa los efectos aleatorios genéticos aditivos, y $e$ es el vector de residuos con una distribución que se asume normal con media igual a $0$ y matriz de covarianza $I\sigma^{2}_{e}$, siendo $I$ representa la matriz identidad, y $\sigma_{e}^{2}$ la varianza residual.

En la ecuación anterior (4.1), se asume que $g$ sigue una distribución normal con media igual a $0$ y matriz de covarianza $A\sigma^{2}_{g}$ en el modelo BLUP, donde $A$ representa la matriz de parentesco basada en información de pedigrí, y $\sigma^{2}_{g}$ es la varianza genética aditiva.

En el modelo ssGBLUP, la matriz A del modelo de la ecuación (4.1) es reemplazada por la matriz H, de la misma dimensión que la matriz A. Dicha matriz H es una función de la matriz A y de la matriz de parentesco basado en marcadores de ADN (o matriz G) [@cite:16], y se define de la siguiente manera:

\begin{equation}
H =
\begin{bmatrix}
A_{11} + A_{12} A_{22}^{-1} ( G - A_{22} ) A_{22}^{-1}  A_{21} & A_{12} A_{22}^{-1} G \\ 
G A_{22}^{-1} A_{12}' & G 
\end{bmatrix}
,
\end{equation}

donde $A_{11}$ es el bloque de A para los individuos sin de genotipo, $A_{22}$ es el bloque de individuos con genotipo y $A_{12}$ y $A_{21}$ son los bloques que contienen las relaciones genéticas aditivas esperadas entre individuos con genotipo y sin genotipo. Inicialmente para el calculo de la matriz H, los datos de genotipado de SNP fueron escalados. Luego, a partir de los datos escalados, se obtuvo la matriz G utilizando el método de @cite:39, $\frac{XX'}{2 \sum_{j=1}^{nSNP} p_{j} (1 - p_{j})}$, donde $X$ es una matriz de dimensión n x nSNP que contiene los genotipos con la codificación numérica descrita anteriormente (0, 1 y 2), $p_{j}$ es la frecuencia del *j*-ésimo SNP, $n$ corresponde al número de individuos y $nSNP$ representa al número de SNP. Para evitar posibles problemas de singularidad, a los elementos de la diagonal de la matriz G se les sumó un valor de 0.05.

Se usaron diferentes matrices H basados en diferentes matrices G, situación que se describe en las dos secciones metodológicas que se describen a continuación. En el anexo A.1 se presenta la función `R` [@cite:52] usada para construir la matriz H.

La heredabilidad en sentido estricto se estimó mediante el método BLUP como:

\begin{equation}
h^{2} = \frac{\sigma^{2}_{g}}{\sigma^{2}_{g} + \sigma^{2}_{e}},
\end{equation}

donde $\sigma^{2}_{g}$ es la varianza genética aditiva y $\sigma^{2}_{e}$ es la varianza residual.

## Generación de pedigríes ancestrales, subconjuntos de datos y habilidad predictiva

En especies de plantas es común que los pedigríes de las poblaciones reproductoras sean completamente, o al menos parcialmente, desconocidos (las razones del porque de esto se describen en @cite:48. Este es el caso de los conjuntos de datos del Rice SNP-Seek Database usados en este estudio. Por esta razón, se utilizó la metodología implementada en el software Molcoanc [@cite:24] con el fin de simular esta información.

Con el software Molcoanc se simulan pedigríes mediante la creación de antepasados virtuales para los individuos genotipados (esto es, la población fundadora), de tal manera que la correlación entre el parentesco genealógico calculado a partir del pedigrí generado tenga la correlación más alta con la matriz de parentesco molecular calculada a partir de los marcadores de ADN proporcionados [@cite:24]. <!-- NOTA: El objetivo del software molcoanc no es recuperar el pedigrí real, sino proporcionar un pedigrí que sea compatible con la dversidad observada y la relación molecular entre los individuos genotipados -->

El software Molcoanc se utilizó para construir tres pedigríes, que se diferenciaron en el número de generaciones ancestro de la población fundadora (Figura 4.3). Este proceso de generación de pedigríes se replicó diez veces para cada pedigrí, con el fin de posteriormente usar cada replica para medir la variabilidad de la predicción mediante el BLUP y el ssGBLUP.

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', message=FALSE, warning=FALSE}

#######################################################
# Pedigrí 1: 300 individuos simulados en 3 generaciones
#######################################################

ped_1 <- read_delim(here('figures', 'geneal_1.csv'), delim = ' ') %>% # Se importa el pedigrí creado son el software molcoanc.
  #write_delim(here('Datos', 'Ped_prueba.txt'), delim = '\t') %>%
  na_if(0)

ped_plot <- editPed(
  sire = ped_1$sire,
  dam = ped_1$dam,
  label = ped_1$id
  )

ped_plot_1 <- ped_plot %>%
  pivot_longer(
    cols = c('sire', 'dam'),
    names_to = 'variable',
    values_to = 'value', # La columna value indica la identificación principal relativa a variable.
    values_drop_na = TRUE # En este primer paso se eliminaron los valores (value) que aparecian como NA.
  ) %>%
  select(-gene) %>% # Tampoco se tuvo en cuenta la variable de generación (gene).
  dplyr::rename(Parent.ID = value) %>%
  rowid_to_column(var = 'Group') %>% # Identificador de grupo (Group) para crear las líneas entre un individuo y su madre o padre.
  select(label, variable, Parent.ID, Group) %>%
  pivot_longer(
    cols = c('label', 'Parent.ID'),
    names_to = 'variable_2',
    values_to = 'value_2'
    ) %>%
  select(-variable) %>%
  dplyr::rename(
    label = value_2,
    variable = variable_2
    ) %>%
  left_join(y = ped_plot, by = 'label')

generateXcoord <- function(size){
  if(size %% 2 != 0 & size != 1){
    newsize <- size - 1
    interval <- 1/newsize
    x <- seq(0, 1, interval)
    }
  if(size %% 2 == 0){
    interval <- 1/size
    x <- seq(0, 1, interval)[-size-1] + diff(seq(0, 1, interval))/2   
    }
  if(size == 1) x <- 0.5
  x
  }

xcoords <- NULL

for(i in unique(ped_plot_1$gene)){
  ids  <- unique(ped_plot_1$label[which(ped_plot_1$gene == i)])
  newx <- generateXcoord(length(ids))
  
  xcoords <- rbind(xcoords,
                   data.frame(label = ids,
                              x = sample(newx, size = length(newx), replace = FALSE))
                   )
  rm(ids, newx)
  }

ped1 <- ped_plot_1 %>%
  left_join(y = xcoords, by = 'label') %>%
  ggplot(data = ., aes(x = x, y = gene)) +
  geom_line(aes(group = Group), alpha = 0.1) +
  geom_point(size = 1.2, colour = 'black', fill = 'black', alpha = 0.2) +
  scale_y_reverse(breaks = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) +
  labs(x = '', y = '', title = 'Pedigrí 1') + # En realidad es el pedigrí cinco pero como me quede con tres pedigríes este sería el tres.
  theme_bw() +
  theme(
    legend.position  = 'none',
    axis.text.x      = element_blank(),
    axis.text.y      = element_text(colour = 'black'),
    axis.ticks.y     = element_blank(),
    axis.ticks.x     = element_blank(),
    axis.text = element_text(face = 'bold', size = 10),
    title = element_text(face = 'bold', size = 9)
    ) #+
  #theme(plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), units = 'cm'))

########################################################
# Pedigrí 2: 1210 individuos simulados en 7 generaciones
########################################################

ped_2 <- read_delim(here('figures', 'geneal_2.csv'), delim = ' ') %>% # Se importa el pedigrí creado son el software molcoanc.
  #write_delim(here('Datos', 'Ped_prueba.txt'), delim = '\t') %>%
  na_if(0)

ped_plot <- editPed(
  sire = ped_2$sire,
  dam = ped_2$dam,
  label = ped_2$id
  )

ped_plot_2 <- ped_plot %>%
  pivot_longer(
    cols = c('sire', 'dam'),
    names_to = 'variable',
    values_to = 'value', # La columna value indica la identificación principal relativa a variable.
    values_drop_na = TRUE # En este primer paso se eliminaron los valores (value) que aparecian como NA.
  ) %>%
  select(-gene) %>% # Tampoco se tuvo en cuenta la variable de generación (gene).
  dplyr::rename(Parent.ID = value) %>%
  rowid_to_column(var = 'Group') %>% # Identificador de grupo (Group) para crear las líneas entre un individuo y su madre o padre.
  select(label, variable, Parent.ID, Group) %>%
  pivot_longer(
    cols = c('label', 'Parent.ID'),
    names_to = 'variable_2',
    values_to = 'value_2'
    ) %>%
  select(-variable) %>%
  dplyr::rename(
    label = value_2,
    variable = variable_2
    ) %>%
  left_join(y = ped_plot, by = 'label')

generateXcoord <- function(size){
  if(size %% 2 != 0 & size != 1){
    newsize <- size - 1
    interval <- 1/newsize
    x <- seq(0, 1, interval)
    }
  if(size %% 2 == 0){
    interval <- 1/size
    x <- seq(0, 1, interval)[-size-1] + diff(seq(0, 1, interval))/2   
    }
  if(size == 1) x <- 0.5
  x
  }

xcoords <- NULL

for(i in unique(ped_plot_2$gene)){
  ids  <- unique(ped_plot_2$label[which(ped_plot_2$gene == i)])
  newx <- generateXcoord(length(ids))
  
  xcoords <- rbind(xcoords,
                   data.frame(label = ids,
                              x = sample(newx, size = length(newx), replace = FALSE))
                   )
  rm(ids, newx)
  }

ped2 <- ped_plot_2 %>%
  left_join(y = xcoords, by = 'label') %>%
  ggplot(data = ., aes(x = x, y = gene)) +
  geom_line(aes(group = Group), alpha = 0.1) +
  geom_point(size = 1.2, colour = 'black', fill = 'black', alpha = 0.2) +
  scale_y_reverse(breaks = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) +
  labs(x = '', y = '', title = 'Pedigrí 2') + # En realidad es el pedigrí cinco pero como me quede con tres pedigríes este sería el tres.
  theme_bw() +
  theme(
    legend.position  = 'none',
    axis.text.x      = element_blank(),
    axis.text.y      = element_text(colour = 'black'),
    axis.ticks.y     = element_blank(),
    axis.ticks.x     = element_blank(),
    axis.text = element_text(face = 'bold', size = 10),
    title = element_text(face = 'bold', size = 9)
    ) #+
  #theme(plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), units = 'cm'))

#########################################################
# Pedigrí 3: 2000 individuos simulados en 10 generaciones
#########################################################

ped_3 <- read_delim(here('figures', 'geneal_3.csv'), delim = '\t') %>% # Se importa el pedigrí creado son el software molcoanc.
  #write_delim(here('Datos', 'Ped_prueba.txt'), delim = '\t') %>%
  na_if(0)

ped_plot <- editPed(
  sire = ped_3$sire,
  dam = ped_3$dam,
  label = ped_3$id
  )

ped_plot_3 <- ped_plot %>%
  pivot_longer(
    cols = c('sire', 'dam'),
    names_to = 'variable',
    values_to = 'value', # La columna value indica la identificación principal relativa a variable.
    values_drop_na = TRUE # En este primer paso se eliminaron los valores (value) que aparecian como NA.
  ) %>%
  select(-gene) %>% # Tampoco se tuvo en cuenta la variable de generación (gene).
  dplyr::rename(Parent.ID = value) %>%
  rowid_to_column(var = 'Group') %>% # Identificador de grupo (Group) para crear las líneas entre un individuo y su madre o padre.
  select(label, variable, Parent.ID, Group) %>%
  pivot_longer(
    cols = c('label', 'Parent.ID'),
    names_to = 'variable_2',
    values_to = 'value_2'
    ) %>%
  select(-variable) %>%
  dplyr::rename(
    label = value_2,
    variable = variable_2
    ) %>%
  left_join(y = ped_plot, by = 'label')

generateXcoord <- function(size){
  if(size %% 2 != 0 & size != 1){
    newsize <- size - 1
    interval <- 1/newsize
    x <- seq(0, 1, interval)
    }
  if(size %% 2 == 0){
    interval <- 1/size
    x <- seq(0, 1, interval)[-size-1] + diff(seq(0, 1, interval))/2   
    }
  if(size == 1) x <- 0.5
  x
  }

xcoords <- NULL

for(i in unique(ped_plot_3$gene)){
  ids  <- unique(ped_plot_3$label[which(ped_plot_3$gene == i)])
  newx <- generateXcoord(length(ids))
  
  xcoords <- rbind(xcoords,
                   data.frame(label = ids,
                              x = sample(newx, size = length(newx), replace = FALSE))
                   )
  rm(ids, newx)
  }

ped3 <- ped_plot_3 %>%
  left_join(y = xcoords, by = 'label') %>%
  ggplot(data = ., aes(x = x, y = gene)) +
  geom_line(aes(group = Group), alpha = 0.1) +
  geom_point(size = 1.2, colour = 'black', fill = 'black', alpha = 0.2) +
  scale_y_reverse(breaks = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) +
  labs(x = '', y = '', title = 'Pedigrí 3') + # En realidad es el pedigrí cinco pero como me quede con tres pedigríes este sería el tres.
  theme_bw() +
  theme(
    legend.position  = 'none',
    axis.text.x      = element_blank(),
    axis.text.y      = element_text(colour = 'black'),
    axis.ticks.y     = element_blank(),
    axis.ticks.x     = element_blank(),
    axis.text = element_text(face = 'bold', size = 10),
    title = element_text(face = 'bold', size = 9)
    ) #+
  #theme(plot.margin = unit(c(1.5, 1.5, 1.5, 1.5), units = 'cm'))

(ped1 | ped2 | ped3) -> Pedigríes

knitr::include_graphics('figures/Pedigríes.pdf', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 4.3:__ Ejemplo de pedigríes generados en la primera replica. En cada pedigrí se generaron distintas generaciones por encima de los individuos de la población fundadora. El número de individuos totales en cada pedigrí fueron: 751 individuos en el pedigrí 1, 1661 en el pedigrí 2 y 2451 en el pedigrí 3. 
:::

Para estudiar el efecto sobre la predictibilidad del número de datos de genotipado de SNP y del número de individuos genotipados, y así determinar el número de marcadores y de individuos en la población de entrenamiento necesarios para implementar el ssGBLUP en datos de arroz, se usaron diferentes subconjuntos de datos con la siguientes características:

1. Distinta cantidad de individuos genotipados: del conjunto total de individuos genotipados (451), se seleccionaron de forma aleatoria 148 y 298 individuos, generando con ello tres subconjuntos de datos (o diferentes poblaciones de entrenamiento) que incluían 148, 298 y 451 individuos.

2. Diferentes densidades de SNP: del conjunto total con 100231 SNP después del control de calidad, se seleccionaron de forma aleatoria mediante el uso de Plink tres subconjuntos de datos de SNP, de manera que el número de marcadores aproximado fuera igual a 1.000, 10.000 y 100.000 SNP.

A continuación, usando los diferentes subconjuntos de datos descritos anteriormente, se obtuvo un total de nueve matrices H con distintas combinaciones de densidad de marcadores e individuos genotipados (Figura 4.4), usando la función `R` descrita en el anexo A.1.

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', fig.showtext = TRUE}

Punto <- data.frame(x = 4.95, y = 0.8)
Puntos <- data.frame(x = c(4.95, 4.85, 5.05, 4.90, 5.00), y = c(1.8, 1.8, 1.8, 1.4, 1.4))
Punto_2 <- data.frame(x = 2.25, y = 5.15)

data.frame(
  x = 4.0, y = 0.5
  ) %>%
  ggplot(aes(x0 = x, y0 = y, r = 0.8)) +
  #geom_blank() +
  
  annotate(geom = 'rect', xmin = 2.0, xmax = 3.25, ymin = 7.5, ymax = 9.5, colour = 'yellow', fill = 'yellow', alpha = 0.2) +
  annotate(geom = 'text', x = 2.625, y = 8.5, label = 'A', size = 6.4, colour = 'black') +
  annotate(geom = 'text', x = 1.7, y = 8.5, label = 'Matriz A', size = 4.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 5.0, xmax = 5.75, ymin = 7.75, ymax = 9.0, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'text', x = 5.375, y = 8.375, label = 'G', size = 6.4, colour = 'black') +
  annotate(geom = 'text', x = 4.7, y = 8.375, label = 'Matriz G', size = 4.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 2.0, xmax = 3.25, ymin = 3.75, ymax = 5.75, colour = 'black', fill = 'white', alpha = 0.2) +
  annotate(geom = 'rect', xmin = 2.4, xmax = 3.15, ymin = 3.95, ymax = 5.05, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'text', x = 1.7, y = 4.75, label = 'Matriz H', size = 4.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 3.5, xmax = 4.5, ymin = 1.8, ymax = 0.8, colour = 'black', fill = 'black', alpha = 0.4) +
  annotate(geom = 'rect', xmin = 3.9, xmax = 4.1, ymin = 0.8, ymax = 0.5, colour = 'black', fill = 'black', alpha = 0.7) +
  geom_circle(aes(x0 = x, y0 = y, r = 0.2), colour = 'black', fill = 'black', alpha = 0.7, size = 0.7) +
  
  annotate(geom = 'rect', xmin = 4.7, xmax = 5.2, ymin = 0.3, ymax = 2.0, colour = 'black', fill = 'black', alpha = 0.2) +
  geom_point(aes(x = x, y = y), data = Punto, size = 1.6, shape = 21, color = 'black', fill = 'black', alpha = 0.9) +
  geom_point(aes(x = x, y = y), data = Puntos, size = 0.6, shape = 21, color = 'black', fill = 'black', alpha = 0.9) +
  annotate(geom = 'text', x = 3.2, y = 1.0, label = 'ssGBLUP', size = 4.6, angle = 90, colour = 'black') +
  
  geom_curve(x = 5.4, xend = 6.2, y = 1.0, yend = 1.0, arrow = arrow(length = unit(0.08, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'dashed') +
  #annotate(geom = 'text', x = 8.8, y = 1.2, label = 'EBV', size = 4.8, colour = 'black') +
  annotate(geom = 'text', x = 6.7, y = 1.0, label = 'GEBV', size = 4.8, colour = 'black') +
  
  geom_curve(x = 2.625, xend = 2.625, y = 7.3, yend = 6.05, arrow = arrow(length = unit(0.05, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'solid') +
  geom_curve(x = 5.375, xend = 3.55, y = 7.45, yend = 4.75, arrow = arrow(length = unit(0.05, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'solid') +
  geom_curve(x = 2.875, xend = 3.95, y = 3.45, yend = 2.1, arrow = arrow(length = unit(0.05, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'solid') +
  
  annotate(geom = 'rect', xmin = 6.25, xmax = 8.25, ymin = 6.5, ymax = 8.8, colour = 'black', fill = 'white', linetype = 'dashed') +
  annotate(geom = 'rect', xmin = 6.25, xmax = 8.25, ymin = 3.95, ymax = 6.25, colour = 'black', fill = 'white', linetype = 'dashed') +
  
  annotate(geom = 'text', x = 2.25, y = 5.15, label = '1-2', family = 'gochi', size = 3.4, colour = 'black') +
  geom_point(aes(x = x, y = y), data = Punto_2, size = 6, shape = 1, color = 'black') +
  
  annotate(geom = 'text', x = 6.35, y = 8.45, label = '1', family = 'gochi', size = 4.4, colour = 'black') +
  annotate(geom = 'rect', xmin = 6.45, xmax = 6.75, ymin = 7.8, ymax = 8.3, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'rect', xmin = 6.8, xmax = 7.4, ymin = 7.3, ymax = 8.3, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'rect', xmin = 7.45, xmax = 8.15, ymin = 6.9, ymax = 8.3, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  
  annotate(geom = 'text', x = 6.35, y = 5.95, label = '2', family = 'gochi', size = 4.4, colour = 'black') +
  annotate(geom = 'text', x = 6.65, y = 5.45, label = '100122', size = 2.8, colour = 'black') +
  annotate(geom = 'text', x = 7.00, y = 4.95, label = '10012210120211', size = 2.8, colour = 'black') +
  annotate(geom = 'text', x = 7.29, y = 4.45, label = '100122101202112001221', size = 2.8, colour = 'black') +
  
  scale_x_continuous(limits = c(1.05, 8.95)) +
  scale_y_continuous(limits = c(0.0, 9.5)) +
  
  theme_bw() +
  #labs(title = 'ssGBLUP') +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        plot.title = element_text(size = 11, face = 'bold')) -> Esquema_1

knitr::include_graphics('figures/Esquema_1.pdf', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 4.4:__ Esquema de construcción de la matriz H a partir de la matriz A y la matriz G, con base en diferentes subconjuntos de datos (o matrices G). El recuadro 1 representa tres matrices G con distinta dimensión dado el número de individuos genotipados y el recuadro 2 representa tres diferentes densidades de SNP, para cada uno de las tres matrices del recuadro 1.
:::

Cabe aclarar que, además de los casos descritos con anterioridad, también se consideró el caso en el que ningún individuo haya sido genotipado y no se usara información de marcadores de ADN.

Los componentes de varianza y los valores fenotípicos predichos se obtuvieron ajustando los modelos BLUP y ssGBLUP descritos anteriormente. Para dicho ajuste se utilizaron los paquetes `BGLR` [@cite:50] y `lme4GS` [@cite:51] del lenguaje de programación `R`, permitiendo así la predicción mediante procedimientos Bayesianos y de máxima verosimilitud restringida (REML), respectivamente. Para la estimación de los componentes de varianza y la predicción de los valores fenotípicos usando el paquete `BGLR`, la Cadena de Markov Monte Carlo (MCMC) se generó con 50000 iteraciones, de las cuales fueron descartadas las primeras 10000 como muestras burn-in. <!--NOTA: La estimación Bayesiana con MCMC provee cadenas con muestras aleatorias de las distribuciones marginales posteriores de cada parámetro o efecto desconocido, a partir de las cuales se pueden hacer las inferencias. Es incorrecto decir que un parámetro genético o que unos valores aditivos han sido estimados “por MCMC” o, “por Gibbs sampling”. La estimación se ha hecho a partir de las funciones de densidad posterior, y se ha usado la media o mediana de cada función para hacer la inferencia estadística; MCMC o Gibbs sampling son meros métodos de cálculo numérico. Decir que se estima un parámetro por Gibbs sampling es como decir que en lugar de predecir por BLUP unos valores aditivos, se predicen por Gauss-Seidel porque este es el método que se ha usado para resolver las ecuaciones del modelo mixto..-->En cuanto al paquete `lme4GS`, no se cambio el número de iteraciones necesarios para alcanzar la convergencia, ya que los autores del paquete [@cite:51] indicaron que el número de iteraciones que se tiene por defecto era suficiente (comunicación personal). 

Se uso el coeficiente de correlación entre los valores fenotípicos observados y predichos como medida de predictibilidad. De acuerdo a @cite:25, la predictibilidad debe obtenerse usando una muestra de validación independiente donde los individuos predichos no deben contribuir a la estimación de parámetros. En este estudio, los valores fenotípicos observados de 48 del total de 451 individuos de arroz de la variedad indica (que corresponde a los individuos clasificados como variedades mejoradas en los conjuntos de datos) se consideraron como fenotipos faltantes <!--(fueron predichos)-->.

## Simulación de fenotipos y genotipos, subconjuntos de datos y habilidad predictiva 

Se evaluó el efecto sobre la predictibilidad del número de datos de genotipado de SNP y del número de individuos genotipados realizando simulación por ordenador, usando el paquete `SeqBreed` [@cite:47] del lenguaje de programación `Python` [@cite:53]. En esta sección se vio la obligación de especular sobre la base genética del carácter tiempo de floración, mientras que en la sección metodológica anterior se usaron los fenotipos y genotipos observados. Los pasos llevados a cabo en la simulación se describen a continuación (Figura 4.5):

1. Uso de genotipos de la población fundadora: para simular los datos de fenotipo y de genotipo se uso el conjunto de datos con los 100.231 SNP resultantes del control de calidad. Dicho conjunto de datos se paso previamente a formato variant call usando Plink, ya que así lo requería el paquete `SeqBreed`. Luego usando las funciones `gg.GFounder()` y `gg.Genome()`, se obtuvo un archivo que indicaba el número de individuos genotipados o individuos de la población fundadora (451), la ploidía (2) y el número de SNP (100.231).

2. Especificación de la arquitectura genética (SNP causales (QTN) y sus efectos) para el carácter tiempo de floración y heredabilidad deseada: se uso el software GCTA [@cite:54] para hacer un un estudio de asociación a nivel genómico (GWAS) para identificar las regiones genómicas asociadas al carácter (Anexo A.2). Luego, en base al GWAS, se generaron los datos que indicaban el efecto de los QTN y su localización, seleccionando solo 50 de ellos proporcional a la varianza aditiva explicada. Por último, se uso la función `gg.QTNs()` sobre estos datos generados, indicando también la heredabilidad del carácter (0.7) de acuerdo a resultados previamente reportados [@cite:26].

3. Generación de pedigríes: se generaron cuatro pedigríes (con diez replicas para medir la variabilidad de la predicción mediante el BLUP y el ssGBLUP), cada uno de ellos con esquemas de cruzamiento diferentes partiendo de la población fundadora con 451 individuos (Tabla 4.1). Usando la función `gg.Population()`, se generó mediante simulación los fenotipos y genotipos de cada uno de los individuos en cada uno de los cuatro pedigríes.

::: {.center data-latex=""}
__Tabla 4.1:__ Representación de los cuatro pedigríes generados. Cada uno de estos pedigríes tienen esquemas de cruzamientos diferentes, dando lugar a distintos número de individuos en la generación $F_{1}$, pero con mismo número de individuos en las generaciones $F_{2}$ y $F_{3}$.
:::

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', message = FALSE}

tribble(
  ~' ', ~'Pedigrí 1', ~'Pedigri 2', ~'Pedigrí 3', ~'Pedigrí 4',
  'F0', '451', '451', '451', '451',
  'F1', '10', '20', '40', '80',
  'F2', '800 (10x80)', '800 (20x40)', '800 (40x20)', '800 (80x10)',
  'F3', '800 (800x1)', '800 (800x1)', '800 (800x1)', '800 (800x1)',
  'Total', '2061', '2071', '2091', '2131'
  ) %>%
  gt() %>%
   tab_footnote(
    footnote = '10 indica el número de descendientes que tendrían los 451 individuos de la generación F0 mediante cruzamiento.',
    locations = cells_body(columns = 'Pedigrí 1', rows = 2)
  ) %>%
   tab_footnote(
    footnote = '10x80 indica el número de descendientes (80) que tendrían cada uno de los 10 individuos de la generación F1 por autofecundación, dando un total de 800 individuos en la generación F2.',
    locations = cells_body(columns = 'Pedigrí 1', rows = 3)
  ) %>%
   tab_footnote(
    footnote = '800x1 indica el número de descendientes (1) que tendrían cada uno de los 800 individuos de la generación F2 por autofecundación, dando un total de 800 individuos en la generación F3.',
    locations = cells_body(columns = 'Pedigrí 1', rows = 4)
  )
```

4. Uso de subconjuntos de datos con diferentes densidades de SNP: se especificaron distintas densidades de SNP usando la función `gg.Chip()`, con el fin de determinar el número de marcadores necesarios para implementar el ssGBLUP. Para ello se usaron los tres subconjuntos de datos de SNP creados en la sección metodológica anterior, con número de marcadores aproximado de 1.000, 10.000 y 100.000 SNP.

5. Implementación de la selección: se uso la función `sel.doEbv()` para llevar a cabo la predicción, usando los modelos BLUP y ssGBLUP descritos anteriormente. En el caso del ssGBLUP, el cual requiere de datos de marcadores de ADN, se uso previamente la función `gg.do_X()` para generar la matriz G. Cabe aclarar que `SeqBreed` genero dicha matriz G de acuerdo a los condiciones descritas anteriormente, como son calcularla utilizando el método de @cite:39, y sumarle a sus elementos de la diagonal un valor de 0.05 para evitar posibles problemas de singularidad.

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', fig.showtext = TRUE}

Puntos <- data.frame(x = c(8.2, 11.8, 13.4, 14.8, 11.4), y = c(8.2, 8.2, 3.35, -0.25, -6.6))

data.frame(
  x = 10.0, y = -7.8
  ) %>%
  ggplot(aes(x0 = x, y0 = y, r = 0.8)) +
  #geom_blank() +
  annotate(geom = 'rect', xmin = 7.8, xmax = 12.2, ymin = 4.3, ymax = 5.1, colour = 'yellow', fill = 'yellow', alpha = 0.2) +
  annotate(geom = 'text', x = 10.0, y = 4.7, label = 'Población fundadora', size = 4.0, colour = 'black') +
  #annotate(geom = 'text', x = 10.0, y = 4.5, label = '(G, y)', size = 4.4, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 3.6, xmax = 8.0, ymin = 7.2, ymax = 8.0, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 5.8, y = 7.6, label = 'Genotipos fundadores', size = 4.0, colour = 'black') +
  geom_curve(x = 5.8, xend = 7.6, y = 6.9, yend = 5.35, arrow = arrow(length = unit(0.1, 'inch')), size = 0.5, color = 'black', curvature = 0.0) +
  
  annotate(geom = 'rect', xmin = 12.0, xmax = 16.4, ymin = 6.4, ymax = 8.0, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 14.2, y = 7.6, label = 'Localización de QTN', size = 4.0, colour = 'black') +
  annotate(geom = 'text', x = 14.2, y = 6.8, label = 'y efectos', size = 4.0, colour = 'black') +
  geom_curve(x = 14.2, xend = 12.4, y = 6.1, yend = 5.35, arrow = arrow(length = unit(0.1, 'inch')), size = 0.5, color = 'black', curvature = 0.0) +
  
  geom_curve(x = 10.0, xend = 10.0, y = 4.1, yend = 1.6, arrow = arrow(length = unit(0.1, 'inch')), size = 0.5, color = 'black', curvature = 0.0) +
  geom_curve(x = 10.8, xend = 10.2, y = 2.75, yend = 2.75, arrow = arrow(length = unit(0.1, 'inch')), size = 0.5, color = 'black', curvature = 0.0) +
  annotate(geom = 'rect', xmin = 11.0, xmax = 13.2, ymin = 2.35, ymax = 3.15, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 12.1, y = 2.75, label = 'Pedigrí', size = 4.0, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 8.0, xmax = 12.0, ymin = 0.5, ymax = 1.3, colour = 'yellow', fill = 'yellow', alpha = 0.2) +
  annotate(geom = 'text', x = 10.0, y = 0.9, label = 'Población', size = 4.0, colour = 'black') +
  
  geom_curve(x = 10.0, xend = 10.0, y = 0.3, yend = -2.0, arrow = arrow(length = unit(0.1, 'inch')), size = 0.5, color = 'black', curvature = 0.0) +
  geom_curve(x = 10.8, xend = 10.2, y = -0.75, yend = -0.75, arrow = arrow(length = unit(0.1, 'inch')), size = 0.5, color = 'black', curvature = 0.0) +
  annotate(geom = 'rect', xmin = 11.0, xmax = 14.6, ymin = -1.25, ymax = -0.35, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 12.8, y = -0.75, label = 'Densidad de SNP', size = 4.0, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 9.6, xmax = 10.8, ymin = -4.0, ymax = -2.2, colour = 'black', fill = 'white') +
  annotate(geom = 'rect', xmin = 10.1, xmax = 10.7, ymin = -3.75, ymax = -2.9, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'text', x = 9.2, y = -3.1, label = 'Matriz H', size = 4.6, angle = 90, colour = 'black') +
  
  geom_curve(x = 10.0, xend = 10.0, y = -4.2, yend = -6.3, arrow = arrow(length = unit(0.1, 'inch')), size = 0.5, color = 'black', curvature = 0.0) +
  annotate(geom = 'rect', xmin = 9.5, xmax = 10.5, ymin = -7.5, ymax = -6.5, colour = 'black', fill = 'black', alpha = 0.4) +
  annotate(geom = 'rect', xmin = 9.95, xmax = 10.05, ymin = -7.8, ymax = -7.5, colour = 'black', fill = 'black', alpha = 0.7) +
  geom_circle(aes(x0 = x, y0 = y, r = 0.2), colour = 'black', fill = 'black', alpha = 0.7, size = 0.7) +
  annotate(geom = 'rect', xmin = 10.7, xmax = 11.1, ymin = -7.8, ymax = -6.5, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'rect', xmin = 10.85, xmax = 10.95, ymin = -7.5, ymax = -7.3, colour = 'black', fill = 'black', alpha = 0.5) +
  annotate(geom = 'rect', xmin = 10.88, xmax = 10.92, ymin = -6.8, ymax = -6.9, colour = 'black', fill = 'black', alpha = 0.5) +
  annotate(geom = 'text', x = 9.1, y = -7.0, label = 'ssGBLUP', size = 4.6, angle = 90, colour = 'black') +
  annotate(geom = 'text', x = 8.7, y = -7.0, label = 'BLUP', size = 4.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'text', x = 8.2, y = 8.2, label = '1', family = 'gochi', size = 5.8, colour = 'black') +
  annotate(geom = 'text', x = 11.8, y = 8.2, label = '2', family = 'gochi', size = 5.8, colour = 'black') +
  annotate(geom = 'text', x = 13.4, y = 3.35, label = '3', family = 'gochi', size = 5.8, colour = 'black') +
  annotate(geom = 'text', x = 14.8, y = -0.25, label = '4', family = 'gochi', size = 5.8, colour = 'black') +
  annotate(geom = 'text', x = 11.4, y = -6.6, label = '5', family = 'gochi', size = 5.8, colour = 'black') +
  geom_point(aes(x = x, y = y), data = Puntos, size = 6, shape = 1, color = 'black') +
  
  scale_x_continuous(limits = c(2.5, 17.5)) +
  scale_y_continuous(limits = c(-8.3, 8.5)) +
  
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank()) -> Esquema_2

knitr::include_graphics('figures/Esquema_2.pdf', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 4.5:__ Esquema de predicción usando simulación con el paquete `SeqBreed`. Figura adaptada de @cite:47.
:::

Para identificar el efecto del número de individuos genotipados sobre la predictibilidad, fueron considerados cuatro casos:

+ Ningún individuo genotipado,

+ Solo los individuos de la generación $F_{2}$ genotipados, 

+ Los individuos de la generaciones $F_{1}$ y $F_{2}$ genotipados y,

+ Todos los individuos de las distintas generaciones genotipadas.

Por último y al igual que en la sección metodológica anteriormente descrita, se uso el coeficiente de correlación entre los valores fenotípicos observados y predichos como medida de predictibilidad. Para esto, los valores fenotípicos observados de los individuos de las generaciones $F_{2}$ y $F_{3}$ se consideraron como fenotipos faltantes.
