```{r, echo = FALSE}

pacman::p_load(cowplot, magick, tibble, gt, dplyr, ggplot2, showtext, here, readr, scales)
font_add_google('Gochi Hand', 'gochi')
showtext_auto()
```

<!-- Para renderizar: bookdown::render_book("index.Rmd", "bookdown::pdf_book") -->

<!--
## Introducción {#intro2}

La teoría de la genética en el estudio de caracteres cuantitativos se estableció hace más de un siglo cuando Ronald Fisher presentó un documento [@cite:1] donde dio a conocer el desarrollo de la teoría del modelo infinitesimal, permitiendo con ello unificar dos de las escuelas de pensamiento que para ese entonces estaban en constante debate: la escuela de pensamiento Mendeliano, cuyo objetivo consistía en localizar y caracterizar factores de herencia, y la escuela de pensamiento biométrico, cuyo origen se remonta a Galton quien buscaba aplicar modelos biométricos con el fin de estudiar las relaciones entre parientes [@cite:2; @cite:3].

La teoría del modelo infinitesimal desarrollado por Fisher establece que la varianza genética de un carácter esta determinado por un gran número de factores Mendelianos, cada uno de los cuales tiene una pequeña contribución aditiva al fenotipo de dicho carácter [@cite:2; @cite:9]. Naturalmente, los modelos usados en estudios de mejoramiento genético han sido concebidos en base a esta teoría [@cite:4; @cite:5], siendo ejemplo de ello el mejor predictor lineal insesgado (BLUP) y el mejor predictor lineal insesgado genómico (GBLUP).

En las ciencias animales, el valor de cría estimado (EBV) se suele predecir en función de un conjunto de modelos que relacionan el fenotipo de una población con la información del pedigrí, mediante el uso del BLUP. No obstante, este método no es factible para poblaciones sin información de pedigrí o con una estructura poblacional compleja, como suele ser el caso de las plantas [@cite:6; @cite:7]. Para el año 2001, Meuwissen, Hayes y Goddard propusieron un método innovador para predecir los valores de cría basado en marcadores de ADN (GEBV), denominándose tiempo después como selección genómica [@cite:6; @cite:3], el cual permitió también superar las limitaciones que suponía el uso del BLUP para predecir los valores de cría en plantas.

Hoy en día, la selección genómica se considera como un método potencial para el mejoramiento genético en plantas [@cite:6], ya que sus ciclos reproductivos suelen ser prolongados, por lo cual con el uso de la selección genómica es posible acelerar dichos ciclos reproductivos con el beneficio adicional de mejorar la tasa de ganancia genética anual por unidad de tiempo y costo [@cite:10; @cite:11]. Además, los datos sobre marcadores de ADN en todo el genoma están cada vez más disponibles para cultivos de relevancia agronómica [@cite:7].

El GBLUP es uno de los métodos más comunes de selección genómica [@cite:11]. De hecho, es el método más popular debido a su simplicidad al sustituir la matriz de relación de parentesco basado en pedigríes [@cite:12] por una matriz de relación basada en marcadores de ADN [@cite:13]. Así mismo, el GBLUP predice con mayor precisión los GEBV en comparación a los EBV del BLUP, debido a que con el primero se estima mejor las relaciones entre individuos [@cite:14], por lo cual la matriz de las relaciones genómicas suele verse como un estimador mejorado de las relaciones basadas en marcadores en lugar de pedigríes [@cite:15].

En términos generales, la selección genómica es un proceso de tres pasos en el que los individuos, sobre la base de su información fenotípica y de pedigrí, son evaluados inicialmente mediante una evaluación genética tradicional por medio del BLUP, y posteriormente a partir de los fenotipos corregidos o pseudo-fenotipos resultantes de esta evaluación genética inicial, es llevado a cabo un análisis genómico de los individuos genotipados mediante el GBLUP. Por último y en base a la información generada, se calculan los GEBV por medio de un índice de selección [@cite:17; @cite:16; @cite:14; @cite:15; @cite:18].

Como no todos los individuos pueden genotiparse, la selección genómica se lleva a cabo a partir del proceso anterior de tres pasos [@cite:17]. Sin embargo, este proceso es tendente a cometer errores [@cite:14], además de presentar inconvenientes como son la perdida de información y la difícultad de generalizarse a caracteres múltiples y maternos [@cite:17; @cite:15]. Conscientes de esto, @cite:17 simplificaron el proceso de varios pasos al desarrollar un método de selección genómica, en el que los fenotipos de los individuos genotipados y no genotipados se analizan conjuntamente para predecir sus valores de cría [@cite:20; @cite:11], método el cual se denomino como mejor predictor lineal insesgado genómico de un solo paso (ssGBLUP).

En el ssGBLUP se dispone de una matriz de parentesco genómica global de individuos genotipados y no genotipados, denominada como matriz de relación combinada o matriz H. Esta matriz se obtiene combinando información de la relación genómica entre individuos genotipados, e información de pedigrí entre individuos genotipados y no genotipados [@cite:20]. Con ello, el proceso anterior de tres pasos tiende a simplificarse al incorporar la información genómica desde el primer paso [@cite:15; @cite:16], sin la necesidad del calculo posterior de fenotipos corregidos y la construcción del índice de selección mencionado previamente [@cite:18].

Al ser una forma de BLUP en el que la matriz de relación de parentesco es sustituida por la matriz de relación combinada [@cite:17; @cite:15; @cite:21], el ssGBLUP se puede adecuar con facilidad a caracteres múltiples y maternos [@cite:21], además se adapta también a las herramientas informaticas ya desarrolladas en base al BLUP [@cite:22]. Este hecho hace del ssGBLUP un método de uso rutinario para la evaluación genómica en animales, donde ha demostrado que produce una predicción más precisa de los valores de cría en comparación a los métodos BLUP y GBLUP antes mencionados [@cite:14; @cite:19; @cite:18]. No obstante, el uso del ssGBLUP para la selección genómica en plantas es más reciente y escaso [@cite:19; @cite:11]. En consecuencia, el __objetivo__
-->

# Materiales y métodos

## Recurso vegetal y datos fenotípicos

Los conjuntos de datos se obtuvieron del [Rice SNP-Seek Database](https://snp-seek.irri.org/index.zul;jsessionid=DD991975FDC4F320BE3C33ED056D0363) , el cual es un cibersitio con información sobre datos de genotipado de SNP y de fenotipos de distintas variedades de arroz (*Oryza sativa L.*). En un estudio previo a este [@cite:26], los datos de genotipado de SNP fueron sometidos a procedimientos de control de calidad, en los que fueron eliminados loci de SNP con una frecuencia del alelo menor de menos de 0.01 y con una tasa de ausencia mayor a 0.01. Para este estudio se consideró eliminar loci de SNP con una frecuencia del alelo menor de menos de 0.05.

Luego, el conjunto de datos de genotipado final se transformó de la codificación de genotipo de nucleótidos (esto es, A, C, T y G) a la codificación numérica (0, 1 y 2 para los homocigotos de clase I, heterocigotos y homocigotos de clase II, respectivamente) para facilitar el análisis estadístico posterior.

Mediante un análisis de componentes principales realizado sobre los datos de genotipado de SNP (Figura 4.1) se observaron diferentes grupos varietales de arroz, de los cuales la variedad indica fue seleccionada para llevar a cabo el estudio una vez la misma fue el grupo varietal con mayor número de individuos genotipados (451 individuos de un total de 738).

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', message=FALSE, warning=FALSE}

# 1. Se importan los archivos de datos.

m_dist <- read_table(here('figures', 'PCA_IND.mdist'), col_names = FALSE) %>%
  select(-X739)

ind <- tibble(id = read_table(here('figures', 'PCA_IND.mdist.id'), col_names = FALSE)[, 2]) # Se extrajo el nombre de los individuos.

esp <- read_delim(here('figures', 'all.phenotypes.csv'), delim = ',') %>%
  select(SNPsubsp) # Se extrajo el nombre de las especies (ADM, ARO, AUS, IND y JAP).

# 2. Se calculan los componentes principales en función del escalado multidimensional.

mds_poblacion <- cmdscale(d = m_dist, eig = TRUE, k = 5)

# 3. Se extraen los vectores propios.

vec_propios <- cbind(esp, ind, mds_poblacion$points)

# 4. Se calcula la proporción de la variación explicada por cada valor propio (por los dos primeros componentes principales).

porc_propio <- round(((mds_poblacion$eig) / sum(mds_poblacion$eig)) * 100, digits = 2)

porc_propio_2 <- porc_propio %>%
  as.tibble() %>%
  slice(1:12) %>%
  rowid_to_column(var = 'componente') %>%
  mutate(componente = as.factor(componente))

# 5. Se visualizan los resultados mediante componentes principales.

graf_bar <- ggplot(data = porc_propio_2, aes(x = componente, y = value)) +
  geom_bar(stat = 'identity', color = 'gray34', fill = 'gray34', alpha = 0.4) +
  #theme_transparent() +
  labs(
   x = 'Componente principal',
   y = 'Variación acumulada (%)'
   ) +
  theme(
    axis.text.x = element_text(face = 'bold', size = 7),
    axis.text.y = element_text(face = 'bold', size = 7, angle = 90),
    axis.title = element_text(face = 'bold', size = 8)
    )

Graf_PCA <- ggplot(data = vec_propios, mapping = aes(x = `1`, y = `2`, color = SNPsubsp, fill = SNPsubsp)) +
  geom_point(alpha = 0.2, size = 4.4) +
  stat_ellipse(aes(color = SNPsubsp), type = 't') +
  geom_hline(yintercept = 0, linetype = 'dotted') +
  geom_vline(xintercept = 0, linetype = 'dotted') +
  scale_color_manual(values = c('yellow', 'black', 'red', 'cyan', 'green')) +
  scale_fill_manual(values = c('yellow', 'black', 'red', 'cyan', 'green')) +
  labs(
   x = paste0('Primer componente (',porc_propio[1],' %)'),
   y = paste0('Segundo componente (',porc_propio[2], '%)'),
   col = 'Variedades de arroz', fill = 'Variedades de arroz'
   ) +
  theme_bw() +
  theme(
    legend.background = element_rect(color = 'gray34', fill = 'white', size = 0.4, linetype = 'dashed'),
    legend.position = c(0.18, 0.24),
    legend.text = element_text(size = 11),
    legend.title = element_text(face = 'bold', size = 11),
    axis.text = element_text(face = 'bold', size = 11),
    axis.title = element_text(face = 'bold', size = 12)
    ) #+
  #annotation_custom(
    #ggplotGrob(x = graf_bar), 
    #xmin = -0.10, xmax = -0.02, 
    #ymin = -0.08, ymax = -0.17
    #)

knitr::include_graphics('figures/Graf_PCA.png', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 4.1:__ Análisis de componentes principales en datos de arroz. Los puntos y las circuferencias de color representan los distintos grupos varietales disponibles: tipo intermedio o mezclado (ADM), aromático (ARO), aus (AUS), indica (IND) y japónica (JAP).
:::

En relación a los datos de fenotipo, el conjunto de datos proporcionó información sobre distintos caracteres fenotípicos de relevancia agronómica como son la trillabilidad de la panícula, el peso del grano, la fuerza del culmo, entre otros (Figura 4.2), siendo seleccionada para la predicción posterior utilizando los modelos de selección genómica el carácter tiempo de floración, ya que en este se observo suficiente variación fenotípica.

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', message = FALSE, warning = FALSE}

Fenotipos <- read_delim(here('figures', 'all.phenotypes.csv'), delim = ',')

# Trillabilidad de la panícula (término descriptivo para la facilidad con la que se extrae el grano de la panícula durante la trilla) ----

Rasgo_1 <- Fenotipos %>%
  mutate(panicle.threshability = as.factor(panicle.threshability)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = panicle.threshability)) +
  geom_bar(color = 'yellow', fill = 'yellow', alpha = 0.2) +
  labs(x = 'Trillabilidad de\n la panícula', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 11, face = 'bold')
    )

# Tiempo de floración ----

Rasgo_2 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data = ., aes(x = Time.to.flowering..from.sowing)) +
  geom_density(color = 'black', fill = 'black', alpha = 0.2) +
  labs(x = 'Tiempo de\n floración', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6, face = 'bold'),
    axis.text.y = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 13, face = 'bold')
    )

# Daño de la sal ----

Rasgo_3 <- Fenotipos %>%
  mutate(Salt.injury.at.EC12 = as.factor(Salt.injury.at.EC12)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = Salt.injury.at.EC12)) +
  geom_bar(color = 'green', fill = 'green', alpha = 0.2) +
  labs(x = 'Daño de la sal', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 11, face = 'bold')
    )

# Longitud de la hoja ----

Rasgo_4 <- Fenotipos %>%
  mutate(leaf.length = as.factor(leaf.length)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = leaf.length)) +
  geom_bar(color = 'red', fill = 'red', alpha = 0.2) +
  labs(x = 'Longitud de\n la hoja', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 11, face = 'bold')
    )

# Fuerza del culmo ----

Rasgo_5 <- Fenotipos %>%
  mutate(culm.strength = as.factor(culm.strength)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = culm.strength)) +
  geom_bar(color = 'cyan', fill = 'cyan', alpha = 0.2) +
  labs(x = 'Fuerza del culmo', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 11, face = 'bold')
    )

# Senescencia de la hoja ----

Rasgo_6 <- Fenotipos %>%
  mutate(leaf.senescence = as.factor(leaf.senescence)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = leaf.senescence)) +
  geom_bar(color = 'cyan', fill = 'cyan', alpha = 0.2) +
  labs(x = 'Senescencia de\n la hoja', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 11, face = 'bold')
    )

# Ángulo de la hoja bandera ----

Rasgo_7 <- Fenotipos %>%
  mutate(flag.leaf.angle = as.factor(flag.leaf.angle)) %>%
  na.omit() %>%
  ggplot(data =., aes(x = flag.leaf.angle)) +
  geom_bar(color = 'red', fill = 'red', alpha = 0.2) +
  labs(x = 'Ángulo de la\n hoja bandera', y = 'Número de observaciones') +
  theme_bw() +
  theme(
    axis.text = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 11, face = 'bold')
    )

# Longitud del grano ----

Rasgo_8 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data =., aes(x = grain.length)) +
  geom_density(color = 'green', fill = 'green', alpha = 0.2) +
  scale_x_continuous(labels = label_number(accuracy = 0.1)) +
  labs(x = 'Longitud del\n grano', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6, face = 'bold'),
    axis.text.y = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 13, face = 'bold')
    )

# Ancho del grano ----

Rasgo_9 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data =., aes(x = grain.width)) +
  geom_density(color = 'black', fill = 'black', alpha = 0.2) +
  labs(x = 'Ancho del\n grano', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6, face = 'bold'),
    axis.text.y = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 13, face = 'bold')
    )

# Peso del grano ----

Rasgo_10 <- Fenotipos %>%
  na.omit() %>%
  ggplot(data =., aes(x = Grain.weight)) +
  geom_density(color = 'yellow', fill = 'yellow', alpha = 0.2) +
  scale_x_continuous(labels = label_number(accuracy = 0.1)) +
  labs(x = 'Peso del grano', y = 'Densidad') +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6, face = 'bold'),
    axis.text.y = element_text(size = 12, face = 'bold'),
    axis.title.x = element_text(size = 8, face = 'bold'),
    axis.title.y = element_text(size = 13, face = 'bold')
    )

(Rasgo_1 | Rasgo_2 | Rasgo_3 | Rasgo_4 | Rasgo_5) / (Rasgo_6 | Rasgo_7 | Rasgo_8 | Rasgo_9 | Rasgo_10) -> Graf_feno

knitr::include_graphics('figures/Graf_feno.png', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 4.2:__ Distribución de cada uno de los caracteres del conjunto de datos fenotípicos de arroz.
:::

## Selección basada en información de pedigrí e información genómica

Para llevar a cabo la predicción usando el mejor predictor lineal insesgado (BLUP) en individuos no genotipados y el mejor predictor lineal insesgado genómico de un solo paso (ssGBLUP) tanto en individuos genotipados como no genotipados, se aplicó el siguiente modelo:

\begin{equation}
y = 1_{n} \mu + Zg + e,
\end{equation}

donde $y$ representa el valor del fenotipo a predecir (es decir, el tiempo de floración) y $Z$ es la matriz de incidencia que relaciona $g$ con $y$. $1_{n}$ es un vector de unos, $\mu$ es la media de la población, el vector $g$ representa los efectos aleatorios genéticos aditivos, y $e$ es el vector de residuos con una distribución que se asume normal con media igual a $0$ y matriz de covarianza $I\sigma^{2}_{e}$.

En la ecuación anterior (4.1), se asume que $g$ sigue una distribución normal con media igual a $0$ y matriz de covarianza $A\sigma^{2}_{g}$ en el modelo BLUP, donde $A$ representa la matriz de parentesco basada en información de pedigrí, y $\sigma^{2}_{g}$ es la varianza genética aditiva.

En el modelo ssGBLUP, la matriz A del modelo de la ecuación (4.1) es reemplazada por la matriz H, de la misma dimensión que la matriz A. Dicha matriz H es una función de la matriz A descrita anteriormente y de la matriz de parentesco basado en marcadores de ADN (o matriz G) [@cite:16], y se define de la siguiente manera:

\begin{equation}
H =
\begin{bmatrix}
A_{11} + A_{12} A_{22}^{-1} ( G - A_{22} ) A_{22}^{-1}  A_{21} & A_{12} A_{22}^{-1} G \\ 
G A_{22}^{-1} A_{12}' & G 
\end{bmatrix}
,
\end{equation}

donde $A_{11}$, $A_{12}$, $A_{21}$ y $A_{22}$ son submatrices de la matriz A, y los subíndices $1$ y $2$ representan los individuos genotipados y no genotipados, respectivamente. Inicialmente para el calculo de la matriz H, los datos de genotipado de SNP fueron escalados. Luego, a partir de los datos escalados, se obtuvo la matriz G utilizando el método de @cite:39, $\frac{XX'}{2 \sum_{j=1}^{nSNP} p_{j} (1 - p_{j})}$, donde $X$ es una matriz de dimensión n x nSNP que contiene los genotipos con la codificación numérica descrita anteriormente (0, 1 y 2), $p_{j}$ es la frecuencia del *j*-ésimo SNP, $n$ corresponde al número de individuos y $nSNP$ representa al número de SNP. Para evitar posibles problemas de singularidad, a los elementos de la diagonal de la matriz G se les sumo un valor de 0.05.

Se usaron diferentes matrices H basados en diferentes matrices G, situación que se describe en las dos metodologías que se describen a continuación. En el anexo A.1 se presenta la función `R` usada para construir la matriz H. 

## Habilidad predictiva, subconjuntos de datos y simulación de pedigríes ancestrales

En lo que respecta a la información de pedigrí, esta no estaba disponible. Por ello, se utilizó la metodología implementada en el software MOLCOANC [@cite:24] con el fin de contar con esta información. Este software <!--crea una genealogía virtual para los fundadores de tal manera que la correlación entre el parentesco genealógico calculado a partir de ese pedigrí virtual tiene la correlación más alta con una matriz proporcionada (la de REA v0.2 en nuestro caso). La metodología es capaz de dar cuenta de cualquier relación conocida a priori (por ejemplo, un par de personas que comparten un padre) y de detectar incompatibilidades mendelianas en las familias propuestas. El número de generaciones por encima de los fundadores se estableció en tres, lo que proporcionó una correlación entre matrices de alrededor del 98%. Cada vez que se agrega un nuevo fundador a la población ex situ, la matriz de parentesco se reevalúa para acomodar las relaciones de la nueva incorporación.-->. (Figura 2.3).

```{r, echo = FALSE, out.width = "100%", fig.align = 'center'}

ggdraw() + draw_image('figures/Pedigríes.png')
```

::: {.center data-latex=""}
__Figura 2.3:__ .
:::

Para identificar el efecto sobre la predictibilidad del tamaño de la muestra de entrenamiento, el número de datos de genotipado de SNP y el número de individuos genotipados, se usaron diferentes subconjuntos de datos (Figura 2.4) con la siguientes características:

1. Diferente información de pedigrí:

2. Diferentes densidades de SNP:

3. Distinta cantidad de individuos genotipados:

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', fig.showtext = TRUE}

Punto <- data.frame(x = 4.95, y = 0.8)
Puntos <- data.frame(x = c(4.95, 4.85, 5.05, 4.90, 5.00), y = c(1.8, 1.8, 1.8, 1.4, 1.4))
Punto_2 <- data.frame(x = 2.25, y = 5.15)

data.frame(
  x = 4.0, y = 0.5
  ) %>%
  ggplot(aes(x0 = x, y0 = y, r = 0.8)) +
  #geom_blank() +
  
  annotate(geom = 'rect', xmin = 2.0, xmax = 3.25, ymin = 7.5, ymax = 9.5, colour = 'yellow', fill = 'yellow', alpha = 0.2) +
  annotate(geom = 'text', x = 2.625, y = 8.5, label = 'A', size = 6.4, colour = 'black') +
  annotate(geom = 'text', x = 1.7, y = 8.5, label = 'Matriz A', size = 4.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 5.0, xmax = 5.75, ymin = 7.75, ymax = 9.0, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'text', x = 5.375, y = 8.375, label = 'G', size = 6.4, colour = 'black') +
  annotate(geom = 'text', x = 4.7, y = 8.375, label = 'Matriz G', size = 4.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 2.0, xmax = 3.25, ymin = 3.75, ymax = 5.75, colour = 'black', fill = 'white', alpha = 0.2) +
  annotate(geom = 'rect', xmin = 2.4, xmax = 3.15, ymin = 3.95, ymax = 5.05, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'text', x = 1.7, y = 4.75, label = 'Matriz H', size = 4.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 3.5, xmax = 4.5, ymin = 1.8, ymax = 0.8, colour = 'black', fill = 'black', alpha = 0.4) +
  annotate(geom = 'rect', xmin = 3.9, xmax = 4.1, ymin = 0.8, ymax = 0.5, colour = 'black', fill = 'black', alpha = 0.7) +
  geom_circle(aes(x0 = x, y0 = y, r = 0.2), colour = 'black', fill = 'black', alpha = 0.7, size = 0.7) +
  
  annotate(geom = 'rect', xmin = 4.7, xmax = 5.2, ymin = 0.3, ymax = 2.0, colour = 'black', fill = 'black', alpha = 0.2) +
  geom_point(aes(x = x, y = y), data = Punto, size = 1.6, shape = 21, color = 'black', fill = 'black', alpha = 0.9) +
  geom_point(aes(x = x, y = y), data = Puntos, size = 0.6, shape = 21, color = 'black', fill = 'black', alpha = 0.9) +
  annotate(geom = 'text', x = 3.2, y = 1.0, label = 'ssGBLUP', size = 4.6, angle = 90, colour = 'black') +
  
  geom_curve(x = 5.4, xend = 6.2, y = 1.0, yend = 1.0, arrow = arrow(length = unit(0.08, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'dashed') +
  #annotate(geom = 'text', x = 8.8, y = 1.2, label = 'EBV', size = 4.8, colour = 'black') +
  annotate(geom = 'text', x = 6.7, y = 1.0, label = 'GEBV', size = 4.8, colour = 'black') +
  
  geom_curve(x = 2.625, xend = 2.625, y = 7.3, yend = 6.05, arrow = arrow(length = unit(0.05, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'solid') +
  geom_curve(x = 5.375, xend = 3.55, y = 7.45, yend = 4.75, arrow = arrow(length = unit(0.05, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'solid') +
  geom_curve(x = 2.875, xend = 3.95, y = 3.45, yend = 2.1, arrow = arrow(length = unit(0.05, 'inch')), size = 0.5, color = 'black', curvature = 0.0, linetype = 'solid') +
  
  annotate(geom = 'rect', xmin = 6.25, xmax = 8.25, ymin = 6.5, ymax = 8.8, colour = 'black', fill = 'white', linetype = 'dashed') +
  annotate(geom = 'rect', xmin = 6.25, xmax = 8.25, ymin = 3.95, ymax = 6.25, colour = 'black', fill = 'white', linetype = 'dashed') +
  
  annotate(geom = 'text', x = 2.25, y = 5.15, label = '1-2', family = 'gochi', size = 3.4, colour = 'black') +
  geom_point(aes(x = x, y = y), data = Punto_2, size = 6, shape = 1, color = 'black') +
  
  annotate(geom = 'text', x = 6.35, y = 8.45, label = '1', family = 'gochi', size = 4.4, colour = 'black') +
  annotate(geom = 'rect', xmin = 6.45, xmax = 6.75, ymin = 7.8, ymax = 8.3, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'rect', xmin = 6.8, xmax = 7.4, ymin = 7.3, ymax = 8.3, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  annotate(geom = 'rect', xmin = 7.45, xmax = 8.15, ymin = 6.9, ymax = 8.3, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  
  annotate(geom = 'text', x = 6.35, y = 5.95, label = '2', family = 'gochi', size = 4.4, colour = 'black') +
  annotate(geom = 'text', x = 6.65, y = 5.45, label = '100122', size = 2.8, colour = 'black') +
  annotate(geom = 'text', x = 7.00, y = 4.95, label = '10012210120211', size = 2.8, colour = 'black') +
  annotate(geom = 'text', x = 7.29, y = 4.45, label = '100122101202112001221', size = 2.8, colour = 'black') +
  
  scale_x_continuous(limits = c(1.05, 8.95)) +
  scale_y_continuous(limits = c(0.0, 9.5)) +
  
  theme_bw() +
  #labs(title = 'ssGBLUP') +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        plot.title = element_text(size = 11, face = 'bold')) -> Esquema_1

knitr::include_graphics('figures/Esquema_1.pdf', auto_pdf = TRUE)
```

::: {.center data-latex=""}
__Figura 2.4:__ Esquema del calculo de la matriz H a partir de las matrices A y G, con base en diferentes subconjuntos de datos. El recuadro 1 representa los tres pedigríes con diferentes número de individuos y que posteriormente se usaron para el calculo de la matriz A. El recuadro 2 representa diferentes densidades de SNP. El recuadro 3 representa matrices G con distinta dimensión dado el número de individuos genotipados.
:::

Se uso el coeficiente de correlación entre los valores fenotípicos observados y predichos como medida de la predictibilidad. De acuerdo a @cite:25, la predictibilidad debe obtenerse usando una muestra de validación independiente o mediante validación cruzada donde los individuos predichos no deben contribuir a la estimación de parámetros. En este sentido, el valor fenotípico observado de 48 del total de 451 individuos de la variedad indica (que corresponde a los individuos clasificados como variedades mejoradas) se considero como faltante.

## Habilidad predictiva, subconjuntos de datos y simulación de fenotipos y genotipos

<!--Evaluación de la precisión con simulaciones por ordenador
Investigamos la precisión para predecir el rendimiento fenotípico realizando simulaciones por computadora basadas en los datos de marcadores de nuestro estudio. 

Bridging the gap between marker-assisted and genomic selection of heading time and plant height in hybrid wheat Y Zhao1,3, MF Mette1,3, M Gowda2,4, CFH Longin2 and JC Reif1-->

```{r, echo = FALSE, out.width = "100%", fig.align = 'center', fig.showtext = TRUE}

Puntos <- data.frame(x = c(8.2, 11.8, 13.4, 14.8), y = c(8.2, 8.2, 3.35, -0.25))

data.frame(
  x = c(2.5:17.5), y = c(-7.0:8.0)
  ) %>%
  ggplot(aes(x, y)) +
  #geom_blank() +
  annotate(geom = 'rect', xmin = 7.8, xmax = 12.2, ymin = 4.3, ymax = 5.1, colour = 'yellow', fill = 'yellow', alpha = 0.2) +
  annotate(geom = 'text', x = 10.0, y = 4.7, label = 'Población fundadora', size = 4.4, colour = 'black') +
  #annotate(geom = 'text', x = 10.0, y = 4.5, label = '(G, y)', size = 4.4, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 3.6, xmax = 8.0, ymin = 7.2, ymax = 8.0, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 5.8, y = 7.6, label = 'Genotipos fundadores', size = 4.0, colour = 'black') +
  geom_curve(x = 5.8, xend = 7.6, y = 6.9, yend = 5.35, arrow = arrow(length = unit(0.1, 'inch')), size = 1.2, color = 'black', curvature = 0.0) +
  
  annotate(geom = 'rect', xmin = 12.0, xmax = 16.4, ymin = 6.4, ymax = 8.0, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 14.2, y = 7.6, label = 'Localización de QTN', size = 4.0, colour = 'black') +
  annotate(geom = 'text', x = 14.2, y = 6.8, label = 'y efectos', size = 4.0, colour = 'black') +
  geom_curve(x = 14.2, xend = 12.4, y = 6.1, yend = 5.35, arrow = arrow(length = unit(0.1, 'inch')), size = 1.2, color = 'black', curvature = 0.0) +
  
  geom_curve(x = 10.0, xend = 10.0, y = 4.1, yend = 1.6, arrow = arrow(length = unit(0.1, 'inch')), size = 1.2, color = 'black', curvature = 0.0) +
  geom_curve(x = 10.8, xend = 10.2, y = 2.75, yend = 2.75, arrow = arrow(length = unit(0.1, 'inch')), size = 1.2, color = 'black', curvature = 0.0) +
  annotate(geom = 'rect', xmin = 11.0, xmax = 13.2, ymin = 2.35, ymax = 3.15, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 12.1, y = 2.75, label = 'Pedigrí', size = 4.0, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 8.0, xmax = 12.0, ymin = 0.5, ymax = 1.3, colour = 'yellow', fill = 'yellow', alpha = 0.2) +
  annotate(geom = 'text', x = 10.0, y = 0.9, label = 'Población', size = 4.4, colour = 'black') +
  
  geom_curve(x = 10.0, xend = 10.0, y = 0.3, yend = -2.0, arrow = arrow(length = unit(0.1, 'inch')), size = 1.2, color = 'black', curvature = 0.0) +
  geom_curve(x = 10.8, xend = 10.2, y = -0.75, yend = -0.75, arrow = arrow(length = unit(0.1, 'inch')), size = 1.2, color = 'black', curvature = 0.0) +
  annotate(geom = 'rect', xmin = 11.0, xmax = 14.6, ymin = -1.25, ymax = -0.35, colour = 'black', fill = 'black', alpha = 0.2) +
  annotate(geom = 'text', x = 12.8, y = -0.75, label = 'Densidad de SNP', size = 4.0, colour = 'black') +
  
  annotate(geom = 'rect', xmin = 9.4, xmax = 11.0, ymin = -4.0, ymax = -2.2, colour = 'black', fill = 'white') +
  annotate(geom = 'rect', xmin = 9.9, xmax = 10.9, ymin = -3.9, ymax = -2.9, colour = 'cyan', fill = 'cyan', alpha = 0.2) +
  #annotate(geom = 'rect', xmin = 9.9, xmax = 10.9, ymin = -2.8, ymax = -2.3, colour = 'gray34', fill = 'gray44', alpha = 0.4) +
  #annotate(geom = 'rect', xmin = 9.5, xmax = 9.8, ymin = -3.9, ymax = -2.9, colour = 'gray34', fill = 'gray44', alpha = 0.4) +
  #annotate(geom = 'rect', xmin = 9.5, xmax = 9.8, ymin = -2.8, ymax = -2.3, colour = 'gray64', fill = 'gray64', alpha = 0.4) +
  annotate(geom = 'text', x = 9.0, y = -3.1, label = 'Matriz H', size = 5.6, angle = 90, colour = 'black') +
  
  annotate(geom = 'text', x = 8.2, y = 8.2, label = '1', family = 'gochi', size = 5.8, colour = 'black') +
  annotate(geom = 'text', x = 11.8, y = 8.2, label = '2', family = 'gochi', size = 5.8, colour = 'black') +
  annotate(geom = 'text', x = 13.4, y = 3.35, label = '3', family = 'gochi', size = 5.8, colour = 'black') +
  annotate(geom = 'text', x = 14.8, y = -0.25, label = '4', family = 'gochi', size = 5.8, colour = 'black') +
  geom_point(aes(x = x, y = y), data = Puntos, size = 6, shape = 1, color = 'black') +
  
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank()) -> Esquema_2

knitr::include_graphics('figures/Esquema_2.pdf', auto_pdf = TRUE)
```



